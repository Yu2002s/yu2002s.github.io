import{_ as l,o as i,c as a,e as t}from"./app-CV__oJZ3.js";const n={};function r(d,e){return i(),a("div",null,e[0]||(e[0]=[t('<h2 id="一、mvvm理解" tabindex="-1"><a class="header-anchor" href="#一、mvvm理解"><span>一、mvvm理解</span></a></h2><ul><li>早期的mvc：在页面中进行操作，=&gt; 后端路由 =&gt; 控制器 =&gt; 数据获取 =&gt; 控制器 =&gt; 回传给页面</li><li>大量的逻辑在控制器这一层</li><li>传统的mvc，大量的逻辑耦合在控制器层，所以维护非常困难</li></ul><p>现在的mvvm</p><ul><li>简化了这一层，即以数据驱动视图模型</li><li>传统的mvvm要求不能手动操作视图，</li><li>Vue具备了mvvm的思想，但是Vue也有新增的ref属性用于操作视图</li></ul><h2 id="二、vue2和vue3的响应式数据" tabindex="-1"><a class="header-anchor" href="#二、vue2和vue3的响应式数据"><span>二、Vue2和Vue3的响应式数据</span></a></h2><p>响应式数据的核心就是数据变化了我们能知道</p><ul><li>对象在Vue2中使用defineproperty将数据定义为响应式数据（使用getter和setter属性），缺陷为需要递归所有的属性，不存在属性不能被监控到，对数组并没有使用defineproperty，因为用户不一定使用索引操作数组，且索引有可能变化 <ul><li>Vue2中减少数据的层级</li><li>不需要双向绑定的数据就不要放在data中</li><li>合理使用Object.freeze将数组冻结，比如1000条死数据，先冻结，不然变化一下更新一下视图</li><li>尽量使用缓存数据</li></ul></li><li>对象在Vue3中使用proxy将对象拦截，不用重写getter和setter方法，性能高，不需要递归每一项属性。</li></ul><h2 id="三、vue中如何检测数组的变化" tabindex="-1"><a class="header-anchor" href="#三、vue中如何检测数组的变化"><span>三、Vue中如何检测数组的变化</span></a></h2><p>Vue2中没有使用defineproperty检测数组(性能差)，Vue2中采用了重写数组的七个方法(pop、push、shift、unshift、reverse、splice、short) Vue3中使用proxy检测数组，不用递归，且性能更高</p><h2 id="四、vue中如何进行依赖收集" tabindex="-1"><a class="header-anchor" href="#四、vue中如何进行依赖收集"><span>四、Vue中如何进行依赖收集</span></a></h2><p>依赖收集的目的是等数据发生了变化，就会更新视图</p><ol><li>每个属性都有一个dep属性，每个对象也有dep属性，每个组件在渲染过程中会调用new Watcher 生成一个渲染watcher(渲染watch、计算属性watcher、用户watcher)一个属性可能有多个watcher，反过来一个watcher也可能存在多个dep中</li><li>当取值的时候，如果Dep.target上有watcher就会将watcher收集起来，等会数据变化的时候会通知自己身上的dep，然后dep会通知所有的watcher执行update更新操作</li></ol><h2 id="五、如何理解vue中的模板编译原理" tabindex="-1"><a class="header-anchor" href="#五、如何理解vue中的模板编译原理"><span>五、如何理解Vue中的模板编译原理</span></a></h2><p>模板编译的核心在于ast树 =&gt; render函数 =&gt; 生成代码</p><ol><li>会将模板转换成ast语法树</li><li>对ast语法树进行优化，标记静态节点</li><li>代码生成，拼接render字符串 使用with + new Function()生成函数</li></ol><p>优化：Vue会将一些节点都加以标记，然后生成vnode几点上会有所表现，vue3中的优化有pathFlag、blockTree、事件缓存、节点缓存</p><h2 id="六、vue生命周期是怎么实现的" tabindex="-1"><a class="header-anchor" href="#六、vue生命周期是怎么实现的"><span>六、Vue生命周期是怎么实现的</span></a></h2><p>生命周期钩子在内部会被Vue维护成数组（mergeOptions）和全局生命周期合并成为最终的数组，当到某个阶段的时候就调用callHook方法执行生命周期</p><h2 id="七、vue生命周期方法有哪些-一般在哪里发送请求" tabindex="-1"><a class="header-anchor" href="#七、vue生命周期方法有哪些-一般在哪里发送请求"><span>七、Vue生命周期方法有哪些？一般在哪里发送请求</span></a></h2><p>在哪儿发送请求都可以，主要看做什么，但是如果是同步操作那肯定要使用mounted 在服务器渲染的时候，我们无法使用浏览器的钩子 因为是异步的关系，ajax是要在同步完成之后才能拿到数据。 事件环！！！</p><h2 id="八、vue-组件的data为什么要是函数" tabindex="-1"><a class="header-anchor" href="#八、vue-组件的data为什么要是函数"><span>八、Vue 组件的data为什么要是函数</span></a></h2><p>比如定义一个组件，组件每次实例化的时候会将组件上的data合并，那么如果data是对象的话 在merge的时候，会将当前的data合并到组件实例内部，如果data是对象，data为引用数据类型，那么有可能会出现data数据被共享的问题，如果data为函数，那么data会执行一次，形成私有作用域，就不会出现污染的问题</p><h2 id="九、vue-mixin-的使用场景和原理" tabindex="-1"><a class="header-anchor" href="#九、vue-mixin-的使用场景和原理"><span>九、Vue.mixin 的使用场景和原理</span></a></h2><p>其价值在解决公共逻辑，比如生命周期、data等 缺陷：为来源不明确，命名可能出现冲突的问题 原理：mergeOptions，会将内容合并到全局Vue的Options上</p><h2 id="十、vue-nexttick在哪儿使用-原理是什么" tabindex="-1"><a class="header-anchor" href="#十、vue-nexttick在哪儿使用-原理是什么"><span>十、Vue.nextTick在哪儿使用？原理是什么？</span></a></h2><p>nextTick功能是批处理，多次调用默认会将逻辑暂存到队列中，稍后同步代码执行完毕后会采用，同步的方式为依次执行队列 开了一个异步定时器，同步执行代码 注： nextTick是将回调函数放到队列中，并不是开启一个异步任务，等宏任务执行完毕的时候会依次执行微任务队列 执行顺序具体看放入的顺序 ==&gt; 渲染Dom ==&gt; 执行回调 ==&gt; 执行回调 ==&gt; 渲染Dom <code>this.a = 1 , this.a = 100</code></p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>会执行两次但是Dom只会渲染一次</p></div><h2 id="十一、computed和watch的区别" tabindex="-1"><a class="header-anchor" href="#十一、computed和watch的区别"><span>十一、computed和watch的区别</span></a></h2><p>区别是 computed：可以用于Dom渲染，computed只有在取值的时候才会执行对应回调，lazy为true所以不会立即执行，有一个dirty实现了缓存机制，多次取值如果依赖的值没有发生改变就不会更改dirty的结果 watch：不能用于Dom渲染，且watch默认会执行一次，watch可以实现异步的监听，变化时立即改变</p><h2 id="十二、vue-set是怎么实现的" tabindex="-1"><a class="header-anchor" href="#十二、vue-set是怎么实现的"><span>十二、Vue.set是怎么实现的</span></a></h2><p>为了实现给以前不存在的对象添加属性可以动态更新页面，对象只有在实例化的时候才会添加getter和setter属性，所以后添加的内容是检测不到的，</p><ul><li>Vue.set({},&quot;name&quot;,&quot;val&quot;)</li></ul><p>先判断对象是不是数组，而且是索引，那么就更改数组的长度，内部会调用splice方法 如果判断是对象，就手动赋值然后主动通知更新</p><h2 id="十三、vue为什么使用虚拟dom" tabindex="-1"><a class="header-anchor" href="#十三、vue为什么使用虚拟dom"><span>十三、Vue为什么使用虚拟dom</span></a></h2><ul><li>最核心的内容是跨端 不同的平台实现方案不同，内部实现可以不局限于浏览器平台</li><li>如果开发者频繁操作dom，会出现浪费性能的情况，虚拟Dom增加了一层缓存，我们先更新虚拟Dom然后更新到页面上</li><li>多次操作dom浏览器会合并</li></ul><h2 id="十四、vue中的diff算法" tabindex="-1"><a class="header-anchor" href="#十四、vue中的diff算法"><span>十四、Vue中的DIff算法</span></a></h2><p>Diff算法是O(n)级别的，采用的同级比较，内部是深度遍历方式，儿子和儿子比较 Vue2</p><ul><li>先比较是否有相同的节点，key tag 相同的节点比较属性，属性相同复用老节点</li><li>比较儿子节点，考虑老节点和新节点的情况</li><li>头头、尾尾、头尾、尾头对比查找并进行复用</li></ul><p>Vue3中使用最长递增子序列 二分查找+贪心算法+前驱节点</p><h2 id="十五、vue中key的作用和原理" tabindex="-1"><a class="header-anchor" href="#十五、vue中key的作用和原理"><span>十五、Vue中key的作用和原理</span></a></h2><p>可以的作用是标识唯一性，在diff算法的时候，可以进行复用。判断是否是相同的节点。</p><ul><li>key在动态列表中不要使用索引</li></ul><p>如果使用的索引，相当于没有写key，而且可能会出现副作用，如果是不会改变的列表，就不会出现这种问题 在diff算法的时候，vue会对比虚拟节点，如果type和属性一样，再对比key是一样的，那么就认为他是可复用的，如果key为index，index是会发生变化的，所以就会发生复用错误的问题</p><h2 id="十六、谈一谈对组件化的理解" tabindex="-1"><a class="header-anchor" href="#十六、谈一谈对组件化的理解"><span>十六、谈一谈对组件化的理解</span></a></h2><p>组件最早出现在webcomponent浏览器可以实现自定义标签，但是很大的问题是性能很差。 Vue中组件化的好处</p><ul><li>是实现组件级别的更新，合理该规划代码，可复用性很强，单向数据流</li><li>可以在组件中使用插槽、事件便于二次开发</li></ul><h2 id="十七、vue的组件渲染流程" tabindex="-1"><a class="header-anchor" href="#十七、vue的组件渲染流程"><span>十七、Vue的组件渲染流程</span></a></h2><p>编写组件（用的时候都是使用标签） 组件 =&gt; ast语法树 =&gt; 创建虚拟节点 =&gt; 挂载到父组件的对应位置上</p><ol><li>注册组件，在当前实例中获取到组件</li><li>Vue.extend根据组件对象创造一个组件类，包含生命周期钩子，init方法还包含 (Sub,children...)</li><li>然后进入渲染阶段，当组件首次渲染的时候会调用组件的init方法，</li><li>根据组件的内容生成虚拟节点，创建节点，插入到页面上</li></ol><p>生命周期钩子会先调用父组件的beforeCreate，created，beforeMount然后执行子组件的beforeCreate，created，breforeMount，mounted最后执行父组件的mounted 如果发生更新的情况 父组件beforeUpdate =&gt; 子组件 beforeUpdate =&gt;子组件updated =&gt; 父组件updated</p><h2 id="十八、vue组件更新流程" tabindex="-1"><a class="header-anchor" href="#十八、vue组件更新流程"><span>十八、Vue组件更新流程</span></a></h2><p>什么情况会导致组件更新</p><ul><li>自己的状态发生了改变</li><li>父组件传过来的props变化，如果内容在组件中被使用了</li><li>父组件更新更新，导致子组件也发生了更新</li></ul><h2 id="十九、vue中异步组件渲染原理" tabindex="-1"><a class="header-anchor" href="#十九、vue中异步组件渲染原理"><span>十九、Vue中异步组件渲染原理</span></a></h2><p>对标图片的懒加载，流程是先渲染一个空节点，之后组件加载完毕了，需要重新强制渲染，重新进行组件加载</p><h2 id="二十、函数组件的优势及其原理" tabindex="-1"><a class="header-anchor" href="#二十、函数组件的优势及其原理"><span>二十、函数组件的优势及其原理</span></a></h2><p>缺点是无状态，无生命周期，没有自己的数据源，可以接收props，单纯的页面渲染可以采用函数组件，正常组件是一个类_init()，但是函数组件是一个函数，性能相对来说比较高 单纯的只用来展示，不用来交互，他没有watcher所以做不了响应式，如果父级被重新渲染，那么函数式组件就重新渲染</p><h2 id="二一、vue组件的传值方式以及之间的区别" tabindex="-1"><a class="header-anchor" href="#二一、vue组件的传值方式以及之间的区别"><span>二一、Vue组件的传值方式以及之间的区别</span></a></h2><ul><li>props，emit 基于事件订阅</li><li>eventBus 在全局上的事件订阅</li><li>Vuex 全局状态管理</li><li>inject provide 开发组件库可以使用</li><li><code>$parent</code> <code>$children</code> 获取父子的实例</li><li>refs 父拿到子的实例</li><li>attrs <code>$listeners</code> 父组件传递给子组件的所有属性和方法</li></ul><h2 id="二二、props和emit实现" tabindex="-1"><a class="header-anchor" href="#二二、props和emit实现"><span>二二、props和emit实现</span></a></h2><p>props 在创建虚拟节点的时候，会被抽离到components中的propsData中，就是在初始化的时候将propsData定义在组件的_data上，最后代理到实例上 emit 给组件绑定事件，核心就是基于发布订阅，<code>$on</code> 和 <code>$emit</code>，解析时会将队列中的对应事件拿出来执行</p><h2 id="二三、-parent-和-children" tabindex="-1"><a class="header-anchor" href="#二三、-parent-和-children"><span>二三、<code>$parent</code> 和 <code>$children</code></span></a></h2><p>在组件初始化的时候，会构造父子关系，然后直接访问就好了</p><h2 id="二三、provide-和-inject" tabindex="-1"><a class="header-anchor" href="#二三、provide-和-inject"><span>二三、provide 和 inject</span></a></h2><p>父组件将数组定义在vm._provide上 子组件通过<code>vm.$parent</code>向上找，最后找到属性然后定义在自己的实例上 provide 和 inject不是响应式的</p><h2 id="二四、-attrs-和-listeners" tabindex="-1"><a class="header-anchor" href="#二四、-attrs-和-listeners"><span>二四、<code>$attrs</code> 和 <code>$listeners</code></span></a></h2><p>获取所有的属性和事件直接定义在实例上，可以将事件和属性快速的一层一层传递，不能实现跨级传递</p><h2 id="二五、-refs" tabindex="-1"><a class="header-anchor" href="#二五、-refs"><span>二五、<code>$refs</code></span></a></h2><p>在实例上定义<code>$refs</code>在实例化的时候映射虚拟节点</p><h2 id="二六、attrs是为了解决什么问题的-provide和inject不能解决他的问题吗" tabindex="-1"><a class="header-anchor" href="#二六、attrs是为了解决什么问题的-provide和inject不能解决他的问题吗"><span>二六、attrs是为了解决什么问题的，provide和inject不能解决他的问题吗？</span></a></h2><p>可以快速的将属性向下传递，一层一层传递，不能实现跨级别传递 provide 和 inject主要是跨级通信，不用再进行传递了，可以在父组件提供出来，子组件直接使用</p><h2 id="二七、v-if和-v-for哪个优先级更高" tabindex="-1"><a class="header-anchor" href="#二七、v-if和-v-for哪个优先级更高"><span>二七、v-if 和 v-for哪个优先级更高</span></a></h2><p>vue2 v-for 比 v-if优先级更高一些 vue3 v-if 比 v-for 优先级更高 如果再写一次就会每一次循环都会做次判断，先创建，然后再删除，非常浪费性能 我们可以在外边包一个template先判断渲染，然后再循环 v-for的原理就是拼接一个循环函数，内部的方法是 -l v-if自动会被定义成三元表达式，</p><h2 id="二八、v-if、v-for、v-model的原理" tabindex="-1"><a class="header-anchor" href="#二八、v-if、v-for、v-model的原理"><span>二八、v-if、v-for、v-model的原理</span></a></h2><p>v-for原理就是拼接一个循环函数，内部用了一个方法 _l v-if 自动会被转义成三元表达式 （v-for和v-if）并不会编译出directive来，再生成代码的时候就将这两个东西转义 v-model原理实际上就是双向绑定原理 v-model在组件中就是value 和 input的语法糖，如果不想用value和input这个名字，可以使用 <code>model：{prop:&quot;xxxx&quot;,event:&quot;xxxx&quot;}</code>实现对value和input默认的修改 如果是放过在表单上就会有差异，如果放在表单上会被拼接成指令，比如输入中文他不会每一个都渲染，而是默认给input事件拼接一个处理中文的指令，在中文输入完毕时渲染。</p><h2 id="二九、slot是怎么实现的-什么时候使用他" tabindex="-1"><a class="header-anchor" href="#二九、slot是怎么实现的-什么时候使用他"><span>二九、slot是怎么实现的，什么时候使用他</span></a></h2><p>插槽分为三种</p><ul><li>具名插槽 构建一个映射表</li><li>普通插槽 是在父组件中渲染，他只能用父组件的数，渲染后传递给子组件，封装普通组件</li><li>作用域插槽 是在子组件中渲染的（vNode），可以使用，子组件数据来继续渲染，常用的为表格中自定义列的内容</li></ul><h2 id="三十、vue-use是干什么的-原理是什么" tabindex="-1"><a class="header-anchor" href="#三十、vue-use是干什么的-原理是什么"><span>三十、Vue.use是干什么的？原理是什么</span></a></h2><ul><li>使用VUE插件，都会使用Vue.use( plugin ) 主要用于保证vue版本，分离插件和vue的强依赖</li><li>原理是将传入的插件放在传入的vue的原型上，用的是传入的vue，所以不会产生vue版本的问题</li></ul><h2 id="三一、组件中name选项的好处和作用是什么" tabindex="-1"><a class="header-anchor" href="#三一、组件中name选项的好处和作用是什么"><span>三一、组件中name选项的好处和作用是什么</span></a></h2><ul><li>好处1. 可以在自己的组件中，循环自己的组件</li><li>好处2. 有了名字后，可以具体定位到具体组件，不停的向上查找找到某个组件，给这个组件派发状态</li></ul><h2 id="三二、vue修饰符有哪些-原理是什么" tabindex="-1"><a class="header-anchor" href="#三二、vue修饰符有哪些-原理是什么"><span>三二、vue修饰符有哪些，原理是什么</span></a></h2><p>stop、prevent、capture、self、once、passive 有两种使用场景</p><ol><li>组件在编译的时候，会对一些修饰符做处理，根据不同的修饰符，生成不同的代码，</li><li>组件在运行时，执行相应的处理</li></ol><ul><li>once、passive、capture得再绑定事件的时候进行特殊处理，在创建的时候依次调用对应的属性钩子来实现创建对应的功能</li></ul><h2 id="三三、vue中-sync的作用和实现原理" tabindex="-1"><a class="header-anchor" href="#三三、vue中-sync的作用和实现原理"><span>三三、vue中.sync的作用和实现原理</span></a></h2><p>.sync是解决v-model不能绑定多个的问题，写法为 <code>&lt;My :xxx.aync=&quot;xxx&quot; :yyy.sync=&quot;yyy&quot;&gt;</code> 当需要触发事件的时候，需要使用 <code>$emit(&quot;update:xxx&quot;, value)</code>进行触发事件和双向绑定 在vue3中.sync被删除了 vue3中是可以写多个v-model的，写法为 <code>&lt;My v-model.xxx=&quot;xxx&quot; v-model.yyy=&quot;yyy&quot;&gt;</code> 当需要触发事件的时候，需要使用<code>$emit(&quot;update:XXX&quot;, value)</code>进行触发事件和双向绑定 所以.sync就函数掉了</p><h2 id="三四、如何理解自定义指令" tabindex="-1"><a class="header-anchor" href="#三四、如何理解自定义指令"><span>三四、如何理解自定义指令</span></a></h2><ol><li>在生成ast语法树的时候，遇到指令会给当前元素添加directives属性</li><li>通过genDeirective生成代码</li><li>在patch前将指令的钩子提取到cbs中，在patch过程中调用对应的钩子</li><li>当执行cbs对应的钩子时，调用对应的指令定义方法</li></ol><h2 id="三五、keep-alive平时在哪里使用-原理是什么" tabindex="-1"><a class="header-anchor" href="#三五、keep-alive平时在哪里使用-原理是什么"><span>三五、keep-alive平时在哪里使用，原理是什么</span></a></h2><ul><li>用于缓存组件的实例，组件的实例上 <code>vm.$el</code>缓存实例就是缓存了dom元素，组件切换的时候如果有缓存，直接复用上次<code>vm.$el</code>的结果</li><li>keep-alive不用做任何渲染操作，内部使用了LRU算法来管理缓存，最近最久未使用法，当超过最大限制的时候，删除最久没有使用的，如果最远的被使用了，就将其优先级提高到最近</li><li>实际上keep-alive是抽象组件，通过props传递 include exclude max最大缓存个数 怎么缓存？ 将插槽的实例以key和value的形式存放在对象中，key也放在数组中，当执行的时候，判断有没有缓存，有缓存就使用，判断需不需要缓存，需要缓存就缓存，不需要就移除，再看看超没超过最大存放数。 缓存怎么更新，当插槽更新的时候，会调用强制更新keep-alive</li></ul>',92)]))}const u=l(n,[["render",r],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/interview/0ibb5prz/","title":"Vue原理面试题","lang":"zh-CN","frontmatter":{"title":"Vue原理面试题","createTime":"2024/07/09 21:03:59","permalink":"/interview/0ibb5prz/","description":"一、mvvm理解 早期的mvc：在页面中进行操作，=> 后端路由 => 控制器 => 数据获取 => 控制器 => 回传给页面 大量的逻辑在控制器这一层 传统的mvc，大量的逻辑耦合在控制器层，所以维护非常困难 现在的mvvm 简化了这一层，即以数据驱动视图模型 传统的mvvm要求不能手动操作视图， Vue具备了mvvm的思想，但是Vue也有新增的re...","head":[["meta",{"property":"og:url","content":"https://www.jdynb.xyz/interview/0ibb5prz/"}],["meta",{"property":"og:site_name","content":"冬日暖雨"}],["meta",{"property":"og:title","content":"Vue原理面试题"}],["meta",{"property":"og:description","content":"一、mvvm理解 早期的mvc：在页面中进行操作，=> 后端路由 => 控制器 => 数据获取 => 控制器 => 回传给页面 大量的逻辑在控制器这一层 传统的mvc，大量的逻辑耦合在控制器层，所以维护非常困难 现在的mvvm 简化了这一层，即以数据驱动视图模型 传统的mvvm要求不能手动操作视图， Vue具备了mvvm的思想，但是Vue也有新增的re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-17T06:13:09.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-17T06:13:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue原理面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-17T06:13:09.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"一、mvvm理解","slug":"一、mvvm理解","link":"#一、mvvm理解","children":[]},{"level":2,"title":"二、Vue2和Vue3的响应式数据","slug":"二、vue2和vue3的响应式数据","link":"#二、vue2和vue3的响应式数据","children":[]},{"level":2,"title":"三、Vue中如何检测数组的变化","slug":"三、vue中如何检测数组的变化","link":"#三、vue中如何检测数组的变化","children":[]},{"level":2,"title":"四、Vue中如何进行依赖收集","slug":"四、vue中如何进行依赖收集","link":"#四、vue中如何进行依赖收集","children":[]},{"level":2,"title":"五、如何理解Vue中的模板编译原理","slug":"五、如何理解vue中的模板编译原理","link":"#五、如何理解vue中的模板编译原理","children":[]},{"level":2,"title":"六、Vue生命周期是怎么实现的","slug":"六、vue生命周期是怎么实现的","link":"#六、vue生命周期是怎么实现的","children":[]},{"level":2,"title":"七、Vue生命周期方法有哪些？一般在哪里发送请求","slug":"七、vue生命周期方法有哪些-一般在哪里发送请求","link":"#七、vue生命周期方法有哪些-一般在哪里发送请求","children":[]},{"level":2,"title":"八、Vue 组件的data为什么要是函数","slug":"八、vue-组件的data为什么要是函数","link":"#八、vue-组件的data为什么要是函数","children":[]},{"level":2,"title":"九、Vue.mixin \\t的使用场景和原理","slug":"九、vue-mixin-的使用场景和原理","link":"#九、vue-mixin-的使用场景和原理","children":[]},{"level":2,"title":"十、Vue.nextTick在哪儿使用？原理是什么？","slug":"十、vue-nexttick在哪儿使用-原理是什么","link":"#十、vue-nexttick在哪儿使用-原理是什么","children":[]},{"level":2,"title":"十一、computed和watch的区别","slug":"十一、computed和watch的区别","link":"#十一、computed和watch的区别","children":[]},{"level":2,"title":"十二、Vue.set是怎么实现的","slug":"十二、vue-set是怎么实现的","link":"#十二、vue-set是怎么实现的","children":[]},{"level":2,"title":"十三、Vue为什么使用虚拟dom","slug":"十三、vue为什么使用虚拟dom","link":"#十三、vue为什么使用虚拟dom","children":[]},{"level":2,"title":"十四、Vue中的DIff算法","slug":"十四、vue中的diff算法","link":"#十四、vue中的diff算法","children":[]},{"level":2,"title":"十五、Vue中key的作用和原理","slug":"十五、vue中key的作用和原理","link":"#十五、vue中key的作用和原理","children":[]},{"level":2,"title":"十六、谈一谈对组件化的理解","slug":"十六、谈一谈对组件化的理解","link":"#十六、谈一谈对组件化的理解","children":[]},{"level":2,"title":"十七、Vue的组件渲染流程","slug":"十七、vue的组件渲染流程","link":"#十七、vue的组件渲染流程","children":[]},{"level":2,"title":"十八、Vue组件更新流程","slug":"十八、vue组件更新流程","link":"#十八、vue组件更新流程","children":[]},{"level":2,"title":"十九、Vue中异步组件渲染原理","slug":"十九、vue中异步组件渲染原理","link":"#十九、vue中异步组件渲染原理","children":[]},{"level":2,"title":"二十、函数组件的优势及其原理","slug":"二十、函数组件的优势及其原理","link":"#二十、函数组件的优势及其原理","children":[]},{"level":2,"title":"二一、Vue组件的传值方式以及之间的区别","slug":"二一、vue组件的传值方式以及之间的区别","link":"#二一、vue组件的传值方式以及之间的区别","children":[]},{"level":2,"title":"二二、props和emit实现","slug":"二二、props和emit实现","link":"#二二、props和emit实现","children":[]},{"level":2,"title":"二三、$parent  和  $children","slug":"二三、-parent-和-children","link":"#二三、-parent-和-children","children":[]},{"level":2,"title":"二三、provide  和  inject","slug":"二三、provide-和-inject","link":"#二三、provide-和-inject","children":[]},{"level":2,"title":"二四、$attrs  和   $listeners","slug":"二四、-attrs-和-listeners","link":"#二四、-attrs-和-listeners","children":[]},{"level":2,"title":"二五、$refs","slug":"二五、-refs","link":"#二五、-refs","children":[]},{"level":2,"title":"二六、attrs是为了解决什么问题的，provide和inject不能解决他的问题吗？","slug":"二六、attrs是为了解决什么问题的-provide和inject不能解决他的问题吗","link":"#二六、attrs是为了解决什么问题的-provide和inject不能解决他的问题吗","children":[]},{"level":2,"title":"二七、v-if\\t和  v-for哪个优先级更高","slug":"二七、v-if和-v-for哪个优先级更高","link":"#二七、v-if和-v-for哪个优先级更高","children":[]},{"level":2,"title":"二八、v-if、v-for、v-model的原理","slug":"二八、v-if、v-for、v-model的原理","link":"#二八、v-if、v-for、v-model的原理","children":[]},{"level":2,"title":"二九、slot是怎么实现的，什么时候使用他","slug":"二九、slot是怎么实现的-什么时候使用他","link":"#二九、slot是怎么实现的-什么时候使用他","children":[]},{"level":2,"title":"三十、Vue.use是干什么的？原理是什么","slug":"三十、vue-use是干什么的-原理是什么","link":"#三十、vue-use是干什么的-原理是什么","children":[]},{"level":2,"title":"三一、组件中name选项的好处和作用是什么","slug":"三一、组件中name选项的好处和作用是什么","link":"#三一、组件中name选项的好处和作用是什么","children":[]},{"level":2,"title":"三二、vue修饰符有哪些，原理是什么","slug":"三二、vue修饰符有哪些-原理是什么","link":"#三二、vue修饰符有哪些-原理是什么","children":[]},{"level":2,"title":"三三、vue中.sync的作用和实现原理","slug":"三三、vue中-sync的作用和实现原理","link":"#三三、vue中-sync的作用和实现原理","children":[]},{"level":2,"title":"三四、如何理解自定义指令","slug":"三四、如何理解自定义指令","link":"#三四、如何理解自定义指令","children":[]},{"level":2,"title":"三五、keep-alive平时在哪里使用，原理是什么","slug":"三五、keep-alive平时在哪里使用-原理是什么","link":"#三五、keep-alive平时在哪里使用-原理是什么","children":[]}],"readingTime":{"minutes":13.63,"words":4090},"git":{"createdTime":1731818749000,"updatedTime":1731823989000,"contributors":[{"name":"jdy2002","email":"jiangdongyu54@gmail.com","commits":2}]},"autoDesc":true,"filePathRelative":"notes/interview/进阶/1.Vue原理面试题.md","bulletin":false}');export{u as comp,p as data};
